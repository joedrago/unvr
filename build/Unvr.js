// Generated by CoffeeScript 2.6.1
(function() {
  var Bottleneck, DEFAULT_CRF, DEFAULT_FOV, DEFAULT_FPS, DEFAULT_OUTPUT_HEIGHT, DEFAULT_OUTPUT_WIDTH, DEFAULT_ROTATED_FOV, Unvr, clone, coloristEXE, deleteIfExists, fatalError, ffmpegEXE, ffprobeEXE, fs, nonaEXE, path, spawn, spawnSync;

  Bottleneck = require('bottleneck');

  fs = require('fs');

  path = require('path');

  ({spawn, spawnSync} = require('child_process'));

  coloristEXE = __dirname + "/../wbin/colorist.exe";

  ffmpegEXE = __dirname + "/../wbin/ffmpeg.exe";

  ffprobeEXE = __dirname + "/../wbin/ffprobe.exe";

  nonaEXE = __dirname + "/../wbin/nona.exe";

  DEFAULT_OUTPUT_WIDTH = 1920;

  DEFAULT_OUTPUT_HEIGHT = 1080;

  DEFAULT_FPS = 30;

  DEFAULT_FOV = 110;

  DEFAULT_ROTATED_FOV = 50;

  DEFAULT_CRF = 20;

  fatalError = function(reason) {
    throw new Error(reason);
  };

  deleteIfExists = function(filename) {
    if (fs.existsSync(filename)) {
      return fs.unlinkSync(filename);
    }
  };

  clone = function(o) {
    return JSON.parse(JSON.stringify(o));
  };

  Unvr = class Unvr {
    constructor(srcFilename, opts) {
      var importData, json, load, settingsFilename;
      this.spawnPromise = this.spawnPromise.bind(this);
      this.srcFilename = srcFilename;
      this.looks = [];
      this.dstW = DEFAULT_OUTPUT_WIDTH;
      this.dstH = DEFAULT_OUTPUT_HEIGHT;
      this.basefov = DEFAULT_FOV;
      this.rangeStart = null;
      this.rangeEnd = null;
      this.step = 30;
      this.promiseLimiter = null;
      this.promiseStep = null;
      this.importCounter = 0;
      this.precache = false;
      this.locks = {};
      // Verbose: 0=Silent, 1=Progress, 2=Verbose
      this.verboseLevel = 1;
      if ((opts != null) && (opts.verbose != null)) {
        this.verboseLevel = opts.verbose;
      }
      this.promiseMax = 3;
      if ((opts != null) && (opts.precache != null)) {
        this.promiseMax = opts.precache;
      }
      load = true;
      if ((opts != null) && (opts.load != null)) {
        load = opts.load;
      }
      if (load) {
        settingsFilename = this.srcFilename + ".unvr";
        if (fs.existsSync(settingsFilename)) {
          this.progressLog(`Loading pre-existing settings: ${settingsFilename}`);
          json = fs.readFileSync(settingsFilename, "utf8");
          importData = JSON.parse(json);
          this.verboseLog("Import Data: ", importData);
          this.import(importData);
        }
      }
      this.getSourceDimensions();
      this.prepareCacheDir();
      this.nonaLies(); // heat this cache up
      this.updateStep();
    }

    export() {
      var e;
      e = {srcW: this.srcW, srcH: this.srcH, srcDuration: this.srcDuration, dstW: this.dstW, dstH: this.dstH, basefov: this.basefov, looks: this.looks, rangeStart: this.rangeStart, rangeEnd: this.rangeEnd, step: this.step};
      return e;
    }

    import(e) {
      var k, v;
      for (k in e) {
        v = e[k];
        this[k] = v;
      }
      this.importCounter += 1;
      return this.updateStep();
    }

    progressLog() {
      if (this.verboseLevel > 0) {
        return console.log.apply(null, arguments);
      }
    }

    verboseLog() {
      if (this.verboseLevel > 1) {
        return console.log.apply(null, arguments);
      }
    }

    spawnPromise(exe, args, opts) {
      return new Promise((resolve, reject) => {
        var p;
        this.verboseLog(`Spawning ${exe}: `, args);
        p = spawn(exe, args, opts);
        return p.on('close', (code) => {
          return resolve(code);
        });
      });
    }

    setRange(start, end) {
      if ((start == null) || (end == null)) {
        this.rangeStart = null;
        this.rangeEnd = null;
        return;
      }
      this.rangeStart = start;
      return this.rangeEnd = end;
    }

    insertLook(afterIndex, timestamp, fov, pitch, yaw, roll) {
      var look;
      look = {timestamp, fov, pitch, yaw, roll};
      if ((afterIndex < 0) || (this.looks.length < 1)) {
        return this.looks.unshift(look);
      } else {
        return this.looks.splice(afterIndex + 1, 0, look);
      }
    }

    getSourceDimensions() {
      var ffprobeArgs, i, len, line, matches, proc, stdoutLines;
      if (!fs.existsSync(this.srcFilename)) {
        fatalError(`File does not exist: ${this.srcFilename}`);
      }
      ffprobeArgs = ['-v', 'error', '-select_streams', 'v:0', '-show_entries', 'stream=width,height,duration', '-of', 'default=nw=1', this.srcFilename];
      this.verboseLog(`Querying width and height: ${this.srcFilename}`);
      proc = spawnSync(ffprobeEXE, ffprobeArgs);
      stdoutLines = String(proc.stdout).split(/\n/);
      this.verboseLog(stdoutLines);
      for (i = 0, len = stdoutLines.length; i < len; i++) {
        line = stdoutLines[i];
        if (matches = line.match(/width=(\d+)/)) {
          this.srcW = parseInt(matches[1]) >> 1;
        }
        if (matches = line.match(/height=(\d+)/)) {
          this.srcH = parseInt(matches[1]);
        }
        if (matches = line.match(/duration=(\d+)/)) {
          this.srcDuration = parseInt(matches[1]);
        }
      }
      this.verboseLog(`Probed source; dimensions: ${this.srcW}x${this.srcH}, duration: ${this.srcDuration}`);
      if ((this.srcW == null) || (this.srcH == null) || (this.srcDuration == null)) {
        return fatalError("Failed to find source dimensions and duration");
      }
    }

    calcBaseCacheFilename(prefix, extension, cacheArgs) {
      var cacheArgKeys, filename, i, k, len;
      cacheArgKeys = Object.keys(cacheArgs).sort();
      filename = prefix;
      for (i = 0, len = cacheArgKeys.length; i < len; i++) {
        k = cacheArgKeys[i];
        filename += `_${k}_${cacheArgs[k]}`;
      }
      if (extension != null) {
        filename += `.${extension}`;
      }
      return filename;
    }

    calcCacheFilename(prefix, extension, cacheArgs) {
      return `${this.cacheDir}/` + this.calcBaseCacheFilename(prefix, extension, cacheArgs);
    }

    prepareCacheDir() {
      var e, parsed;
      parsed = path.parse(this.srcFilename);
      this.cacheDir = `./unvr.cache.${parsed.name}`;
      try {
        fs.mkdirSync(this.cacheDir);
      } catch (error) {
        e = error;
      }
      // who cares
      if (!fs.existsSync(this.cacheDir)) {
        return fatalError(`Failed to create cache dir: ${this.cacheDir}`);
      }
    }

    getLook(timestamp) {
      var i, len, look, prevLook, ref;
      prevLook = null;
      ref = this.looks;
      for (i = 0, len = ref.length; i < len; i++) {
        look = ref[i];
        if (timestamp < look.timestamp) {
          break;
        }
        prevLook = look;
      }
      if (prevLook == null) {
        prevLook = {
          timestamp: 0,
          roll: 0,
          pitch: 0,
          yaw: 0,
          fov: 0
        };
      }
      return prevLook;
    }

    async nonaLies() {
      var liesInputs, nonaLiesFilename;
      liesInputs = {srcW: this.srcW, srcH: this.srcH};
      nonaLiesFilename = this.calcCacheFilename('nona_lies', 'png', liesInputs);
      if (!fs.existsSync(nonaLiesFilename)) {
        await this.spawnPromise(coloristEXE, ["generate", `${liesInputs.srcW}x${liesInputs.srcH},#000000`, nonaLiesFilename]);
      }
      if (!fs.existsSync(nonaLiesFilename)) {
        fatalError("Failed to make nona_lies.png");
      }
      return this.calcBaseCacheFilename('nona_lies', 'png', liesInputs);
    }

    spawnOptions() {
      if (this.verboseLevel > 1) {
        return {
          stdio: 'inherit'
        };
      }
      return {
        stdio: 'ignore'
      };
    }

    async updateStep() {
      var endRange, i, importCounterStart, promises, ref, ref1, ref2, signals, startRange, t;
      if (!this.precache) {
        return;
      }
      if (this.step <= 1) {
        return;
      }
      if (this.promiseStep !== null) {
        return;
      }
      if (this.promiseMax < 1) {
        return;
      }
      importCounterStart = this.importCounter;
      this.promiseLimiter = new Bottleneck({
        maxConcurrent: this.promiseMax
      });
      this.promiseStep = this.step;
      this.progressLog(`Performing precache step(${this.promiseStep}, ${this.promiseMax} concurrent)...`);
      promises = [];
      signals = {
        atLeastOneBailed: false
      };
      startRange = 0;
      endRange = this.srcDuration;
      if ((this.rangeStart != null) && this.rangeEnd) {
        startRange = this.rangeStart;
        endRange = this.rangeEnd;
      }
      for (t = i = ref = startRange, ref1 = endRange, ref2 = this.promiseStep; ref2 !== 0 && (ref2 > 0 ? i <= ref1 : i >= ref1); t = i += ref2) {
        ((t, signals) => {
          return promises.push(this.promiseLimiter.schedule(() => {
            return new Promise((resolve, reject) => {
              if (importCounterStart !== this.importCounter) {
                this.verboseLog(`Bailing on generation of frame ${t}`);
                signals.atLeastOneBailed = true;
                resolve();
                return;
              }
              return this.preview(t).then(function() {
                return resolve();
              });
            });
          }));
        })(t, signals);
      }
      await Promise.all(promises);
      if (!signals.atLeastOneBailed) {
        this.progressLog(`Full precache step(${this.promiseStep}) complete.`);
      }
      if (importCounterStart !== this.importCounter) {
        if (this.step === 1) {
          this.progressLog(`Step disabled (${this.promiseStep} -> ${this.step}); Bailing out.`);
        } else {
          this.progressLog("Settings changed; Rescanning...");
        }
        setTimeout(() => {
          return this.updateStep();
        }, 100);
      }
      this.promiseLimiter = null;
      return this.promiseStep = null;
    }

    prepareNona(look, timestamp) {
      var nonaInputs;
      nonaInputs = {
        dstW: this.dstW,
        dstH: this.dstH,
        fov: look.fov > 0 ? look.fov : this.basefov,
        roll: look.roll,
        pitch: look.pitch,
        yaw: look.yaw,
        timestamp: timestamp
      };
      return nonaInputs;
    }

    async generateNona(nonaInputs, look, timestamp) {
      var nona, nonaArgs, nonaConfig, nonaConfigFilename, nonaFilePrefix, nonaRawXFilename, nonaRawYFilename, nonaXFilename, nonaYFilename;
      nonaConfigFilename = this.calcCacheFilename('nona', 'cfg', nonaInputs);
      nonaXFilename = this.calcCacheFilename('nona_x', 'tif', nonaInputs);
      nonaYFilename = this.calcCacheFilename('nona_y', 'tif', nonaInputs);
      if (!fs.existsSync(nonaConfigFilename) || !fs.existsSync(nonaXFilename) || !fs.existsSync(nonaYFilename)) {
        nonaFilePrefix = this.calcCacheFilename('nona_tmp', null, {timestamp});
        nonaRawXFilename = nonaFilePrefix + "0000_x.tif";
        nonaRawYFilename = nonaFilePrefix + "0000_y.tif";
        deleteIfExists(nonaRawXFilename);
        deleteIfExists(nonaRawYFilename);
        deleteIfExists(nonaXFilename);
        deleteIfExists(nonaYFilename);
        nonaConfig = `p w${nonaInputs.dstW} h${nonaInputs.dstH} f0 v${nonaInputs.fov}\ni f4 r${nonaInputs.roll} p${nonaInputs.pitch} y${nonaInputs.yaw} v180 n\"${(await this.nonaLies())}\"\n`;
        nonaArgs = ['-o', nonaFilePrefix, '-c', nonaConfigFilename];
        this.verboseLog(nonaConfig);
        fs.writeFileSync(nonaConfigFilename, nonaConfig);
        await this.spawnPromise(nonaEXE, nonaArgs, this.spawnOptions());
        if (!fs.existsSync(nonaRawXFilename) || !fs.existsSync(nonaRawYFilename)) {
          fatalError("Failed to generate nona TIFFs");
        }
        fs.renameSync(nonaRawXFilename, nonaXFilename);
        fs.renameSync(nonaRawYFilename, nonaYFilename);
        deleteIfExists(nonaFilePrefix + "0000.tif");
        deleteIfExists(nonaConfigFilename);
        if (!fs.existsSync(nonaXFilename) || !fs.existsSync(nonaYFilename)) {
          fatalError("Failed to rename nona TIFFs");
        }
      }
      nona = {
        inputs: nonaInputs,
        x: nonaXFilename,
        y: nonaYFilename
      };
      return nona;
    }

    lock(timestamp) {
      return new Promise((resolve, reject) => {
        var interval, waited;
        if (!this.locks[timestamp]) {
          // console.log "Locked: (#{timestamp})"
          this.locks[timestamp] = true;
          resolve();
          return;
        }
        waited = false;
        return interval = setInterval(() => {
          if (this.locks[timestamp]) {
            // console.log "Waiting for lock... (#{timestamp})"
            return waited = true;
          } else {
            // if waited
            // console.log "Finally got lock! (#{timestamp})"
            this.locks[timestamp] = true;
            // console.log "Locked: (#{timestamp})"
            clearInterval(interval);
            return resolve();
          }
        }, 500);
      });
    }

    unlock(timestamp) {
      if (!this.locks[timestamp]) {
        fatalError("Your lock code is garbage.");
      }
      // console.log "Unlocked: (#{timestamp})"
      return this.locks[timestamp] = false;
    }

    async preview(previewTimestamp) {
      var data, ffmpegArgs, ffmpegFilter, look, lookIndex, nona, nonaInputs, previewFilename, previewInputs;
      await this.lock(previewTimestamp);
      look = this.getLook(previewTimestamp);
      nonaInputs = this.prepareNona(look, previewTimestamp);
      previewInputs = clone(nonaInputs);
      previewInputs.timestamp = previewTimestamp;
      previewFilename = this.calcCacheFilename("preview", "jpg", previewInputs);
      if (!fs.existsSync(previewFilename)) {
        nona = (await this.generateNona(nonaInputs, look, previewTimestamp));
        ffmpegArgs = [];
        ffmpegArgs.push('-ss');
        ffmpegArgs.push(String(previewTimestamp));
        ffmpegArgs.push('-i');
        ffmpegArgs.push(this.srcFilename);
        ffmpegArgs.push('-i');
        ffmpegArgs.push(nona.x);
        ffmpegArgs.push('-i');
        ffmpegArgs.push(nona.y);
        lookIndex = 0;
        ffmpegFilter = "";
        ffmpegFilter += `[0:v]trim=start=0,fps=${DEFAULT_FPS},setpts=PTS-STARTPTS[raw${lookIndex}];`;
        ffmpegFilter += `[raw${lookIndex}][1][2]remap`;
        ffmpegArgs.push("-filter_complex");
        ffmpegArgs.push(ffmpegFilter);
        ffmpegArgs.push('-an');
        ffmpegArgs.push('-frames:v');
        ffmpegArgs.push('1');
        ffmpegArgs.push(previewFilename);
        deleteIfExists(previewFilename);
        await this.spawnPromise(ffmpegEXE, ffmpegArgs, this.spawnOptions());
        if (fs.existsSync(previewFilename)) {
          this.progressLog(`Generated preview for timestamp ${previewTimestamp}.`);
        } else {
          await this.spawnPromise(coloristEXE, ["generate", `${this.dstW}x${this.dstH},#ff00ff`, previewFilename], this.spawnOptions());
          this.progressLog(`Generated PLACEHOLDER preview for timestamp ${previewTimestamp}.`);
        }
        deleteIfExists(nona.x);
        deleteIfExists(nona.y);
      }
      data = fs.readFileSync(previewFilename);
      this.unlock(previewTimestamp);
      return data;
    }

    async generate(dstFilename) {
      var concatFilename, concatString, duration, ffmpegArgs, ffmpegFilter, filelist, filelistFilename, i, isLastLook, j, l, len, len1, len2, look, lookFilename, lookFilenames, lookIndex, looks, needsStartingLook, nona, nonaInputs, ref, startFOV, startingLook;
      // Make a shallow copy of @looks so we can prepend/append
      looks = [];
      ref = this.looks;
      for (i = 0, len = ref.length; i < len; i++) {
        look = ref[i];
        looks.push(look);
      }
      needsStartingLook = false;
      if (looks.length === 0) {
        needsStartingLook = true;
      } else if (looks[0].timestamp !== 0) {
        needsStartingLook = true;
      }
      if (needsStartingLook) {
        startFOV = this.basefov;
        if (looks.length > 0) {
          startFOV = looks[0].fov;
        }
        startingLook = {
          timestamp: 0,
          roll: 0,
          pitch: 0,
          yaw: 0,
          fov: startFOV
        };
        looks.unshift(startingLook);
      }
      lookFilenames = [];
      for (lookIndex = j = 0, len1 = looks.length; j < len1; lookIndex = ++j) {
        look = looks[lookIndex];
        isLastLook = lookIndex === (looks.length - 1);
        lookFilename = this.calcCacheFilename("look", "mp4", {
          index: lookIndex
        });
        lookFilenames.push(this.calcBaseCacheFilename("look", "mp4", {
          index: lookIndex
        }));
        nonaInputs = this.prepareNona(look, 0);
        nona = (await this.generateNona(nonaInputs, look, 0));
        ffmpegArgs = [];
        ffmpegArgs.push('-ss');
        ffmpegArgs.push(String(look.timestamp));
        ffmpegArgs.push('-i');
        ffmpegArgs.push(this.srcFilename);
        ffmpegArgs.push('-i');
        ffmpegArgs.push(nona.x);
        ffmpegArgs.push('-i');
        ffmpegArgs.push(nona.y);
        ffmpegFilter = "";
        duration = 0;
        if (lookIndex !== (looks.length - 1)) {
          duration = looks[lookIndex + 1].timestamp - look.timestamp;
        }
        if (duration > 0) {
          ffmpegFilter += `[0:v]trim=start=0:duration=${duration},fps=${DEFAULT_FPS},setpts=PTS-STARTPTS[raw${lookIndex}];`;
        } else {
          ffmpegFilter += `[0:v]trim=start=0,fps=${DEFAULT_FPS},setpts=PTS-STARTPTS[raw${lookIndex}];`;
        }
        ffmpegFilter += `[raw${lookIndex}][1][2]remap`;
        ffmpegArgs.push("-filter_complex");
        ffmpegArgs.push(ffmpegFilter);
        ffmpegArgs.push('-an');
        if (isLastLook && (this.rangeEnd != null)) {
          ffmpegArgs.push('-t');
          ffmpegArgs.push(`${this.rangeEnd - look.timestamp}`);
        }
        ffmpegArgs.push('-crf');
        ffmpegArgs.push(String(DEFAULT_CRF));
        ffmpegArgs.push('-g');
        ffmpegArgs.push('1');
        ffmpegArgs.push('-keyint_min');
        ffmpegArgs.push('1');
        ffmpegArgs.push(lookFilename);
        this.progressLog(`Rendering look ${lookIndex + 1}/${looks.length} ...`);
        deleteIfExists(lookFilename);
        await this.spawnPromise(ffmpegEXE, ffmpegArgs, this.spawnOptions());
        if (!fs.existsSync(lookFilename)) {
          fatalError(`Failed to generate look ${lookIndex}`);
        }
        deleteIfExists(nona.x);
        deleteIfExists(nona.y);
      }
      this.progressLog(`Concatenating ${looks.length} video stream(s) ...`);
      ffmpegArgs = [];
      ffmpegFilter = "";
      concatString = "";
      filelist = "";
      filelistFilename = this.calcCacheFilename("concatFileList", "txt", {});
      concatFilename = this.calcCacheFilename("allvideo", "mp4", {});
      for (l = 0, len2 = lookFilenames.length; l < len2; l++) {
        lookFilename = lookFilenames[l];
        filelist += `file '${lookFilename}'\n`;
      }
      fs.writeFileSync(filelistFilename, filelist);
      ffmpegArgs.push('-f');
      ffmpegArgs.push('concat');
      ffmpegArgs.push('-safe');
      ffmpegArgs.push('0');
      ffmpegArgs.push('-i');
      ffmpegArgs.push(filelistFilename);
      ffmpegArgs.push('-c');
      ffmpegArgs.push('copy');
      ffmpegArgs.push(concatFilename);
      deleteIfExists(concatFilename);
      await this.spawnPromise(ffmpegEXE, ffmpegArgs, this.spawnOptions());
      this.progressLog("Mixing video and audio streams ...");
      ffmpegArgs = [];
      if (this.rangeStart != null) {
        ffmpegArgs.push('-ss');
        ffmpegArgs.push(`${this.rangeStart}`);
      }
      ffmpegArgs.push('-i');
      ffmpegArgs.push(concatFilename);
      if (this.rangeStart != null) {
        ffmpegArgs.push('-ss');
        ffmpegArgs.push(`${this.rangeStart}`);
      }
      ffmpegArgs.push('-i');
      ffmpegArgs.push(this.srcFilename);
      ffmpegArgs.push('-c');
      ffmpegArgs.push('copy');
      ffmpegArgs.push('-map');
      ffmpegArgs.push('0:v:0');
      ffmpegArgs.push('-map');
      ffmpegArgs.push('1:a:0');
      ffmpegArgs.push('-shortest');
      ffmpegArgs.push('-aspect');
      ffmpegArgs.push(`${this.dstW}:${this.dstH}`);
      ffmpegArgs.push(dstFilename);
      deleteIfExists(dstFilename);
      await this.spawnPromise(ffmpegEXE, ffmpegArgs, this.spawnOptions());
      if (!fs.existsSync(dstFilename)) {
        fatalError("Failed to create final file.");
      }
      this.progressLog(`Generated: ${dstFilename}`);
    }

  };

  module.exports = Unvr;

}).call(this);
